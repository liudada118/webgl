<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas id="webgl" width="500" height="500" style="background-color: blue"></canvas>
</body>
<script id="vertex_shader_2d" type="notjs">

    // 一个属性变量，将会从缓冲中获取数据
    attribute vec4 a_position;
   
    // 所有着色器都有一个main方法
    void main() {
   
      // gl_Position 是一个顶点着色器主要设置的变量
      gl_Position = a_position;
    }
   
  </script>

<script id="fragmeng_shader_2d" type="notjs">

    // 片断着色器没有默认精度，所以我们需要设置一个精度
    // mediump是一个不错的默认值，代表“medium precision”（中等精度）
    precision mediump float;
   
    void main() {
      // gl_FragColor是一个片断着色器主要设置的变量
      gl_FragColor = vec4(1, 0, 0.5, 1); // 返回“瑞迪施紫色”
    }
   
  </script>

<script>
    const canvas = document.getElementById('webgl')
    const gl = canvas.getContext('webgl')
    console.log(document.querySelector('#vertex_shader_2d').textContent)
    const vertexShaderSource = document.querySelector('#vertex_shader_2d').text
    const fragmentShaderSource = document.querySelector('#fragmeng_shader_2d').text

    // 赋值顶点着色器和片元着色器赋值
    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource)
    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)

    // 创建一个着色程序
    var program = createProgram(gl, vertexShader, fragmentShader)

    // gl.drawArrays(gl.POINTS, 0, 1)
    // 获取 物体的position
    var positionAttributeLocation = gl.getAttribLocation(program, 'a_position')

    // 创建一个缓冲
    var positionBuffer = gl.createBuffer()

    // 绑定缓冲到webgl 的全局变量 ARRAY_BUFFER上
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)


    // 将JavaScript数组positions，转化为webgl需要的强类型 Float32Array，将positions绑定到gl.ARRAY_BUFFER上，gl.STATIC_DRAW 值这些数据不会经常改变
    var positions = [
        0, 0,
        0, 0.5,
        0.7, 0,
    ];

    gl.bufferData(gl.ARRAY_BUFFER , new Float32Array(positions) , gl.STATIC_DRAW)

    function createShader(gl, type, source) {
        // 创建 shader
        var shader = gl.createShader(type)
        // 赋值shader
        gl.shaderSource(shader, source)
        // 编译shader
        gl.compileShader(shader)

        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader
        }

        console.log(gl.getShaderInfoLog(shader))
        gl.deleteShader(shader)
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        // 创建程序 program
        var program = gl.createProgram()

        // 给程序绑定shader
        gl.attachShader(program, vertexShader)
        gl.attachShader(program, fragmentShader)

        // 链接program
        gl.linkProgram(program)

        // 使用program
        gl.useProgram(program)
        var success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
            return program
        }

        console.log(gl.getProgramInfoLog(program))
        gl.deleteProgram(program)
    }
</script>

</html>